{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/print","webpackCompilationHash":"52e617659f20e5fac826","result":{"data":{"deck":{"id":"524716f0-c4b8-59b9-be39-71b450728e45","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = vsDark;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"Dependency Injection with \", mdx(\"br\", null), \" \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"Providers\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"Context\")), mdx(\"p\", null, \"Leveraging React Hooks to write scalable testable applications\"), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"App.tsx\\\"\",\n    \"title\": \"\\\"App.tsx\\\"\"\n  }), \"const App: React.FunctionComponent = () => {\\n  return (\\n    <div>\\n      <div>My cool header</div>\\n      <Results />\\n    </div>\\n  );\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Result.tsx\\\"\",\n    \"title\": \"\\\"Result.tsx\\\"\"\n  }), \"const Results = () => {\\n  const [data, isLoading, error] = useFoo();\\n  if (isLoading) {\\n    return <div>Loading...</div>;\\n  }\\n  if (error) {\\n    return <div>Error: {error.message}</div>;\\n  }\\n  return <MyFooTable data={data} />;\\n}\\n\")))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"useFoo.ts\\\"\",\n    \"title\": \"\\\"useFoo.ts\\\"\"\n  }), \"class FooService {\\n  async getData(): Promise<Data> {\\n    const response = await fetch('/api/data');\\n    const json = await response.json();\\n    return json;\\n  }\\n}\\n\\nexport const useFoo = () => {\\n  const [data, setData] = useState();\\n  const [loading, setLoading] = useState(true);\\n  const [error, setError] = useState();\\n  const fooService = new FooService();\\n  \\n  useEffect(() => {\\n    const isCanceled = false;\\n    asyncEffect();\\n    return () => {\\n      isCanceled = true;\\n    }\\n\\n    async function asyncEffect() {\\n      try {\\n        const data = await fooService.getData();\\n        if (isCanceled) {\\n          return;\\n        }\\n        setData(data);\\n        setLoading(false);\\n      } catch(error) {\\n        setError(error);\\n        setLoading(false);\\n      }\\n    }\\n  }, []);\\n\\n  return [data, loading, error];\\n}\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Result.test.ts\\\"\",\n    \"title\": \"\\\"Result.test.ts\\\"\"\n  }), \"describe('<Result />', () => {\\n  it('renders a loading state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => new Promise(res => {})) // halt requests\\n    const { getByText } = render(<Result />);\\n    expect(getByText('Loading...')).toBeInTheDocument();\\n  });\\n\\n  it('renders an error state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => Promise.reject(new Error('Bad')));\\n    const { getByText } = render(<Result />);\\n    expect(getByText('Error: Bad')).toBeInTheDocument();\\n  });\\n\\n  it('renders the result state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => Promise.resolve([thing1, thing2]));\\n    const { getByText } = render(<Result />);\\n    expect(getByText(thing1.id)).toBeInTheDocument();\\n    expect(getByText(thing2.id)).toBeInTheDocument();\\n  });\\n});\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"16:22 title=\\\"This doesn't work\\\"\",\n    \"16:22\": true,\n    \"title\": \"\\\"This\",\n    \"doesn't\": true,\n    \"work\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"describe('<Result />', () => {\\n  it('renders a loading state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => new Promise(res => {})) // halt requests\\n    const { getByText } = render(<Result />);\\n    expect(getByText('Loading...')).toBeInTheDocument();\\n  });\\n\\n  it('renders an error state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => Promise.reject(new Error('Bad')));\\n    const { getByText } = render(<Result />);\\n    expect(getByText('Error: Bad')).toBeInTheDocument();\\n  });\\n\\n  it('renders the result state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => Promise.resolve({\\n      json: () => Promise.resolve([thing1, thing2]),\\n    }));\\n    const { getByText } = render(<Result />);\\n    expect(getByText(thing1.id)).toBeInTheDocument();\\n    expect(getByText(thing2.id)).toBeInTheDocument();\\n  });\\n});\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"18:20 subtitle=\\\"This is tightly coupled with service implementation\\\"\",\n    \"18:20\": true,\n    \"subtitle\": \"\\\"This\",\n    \"is\": true,\n    \"tightly\": true,\n    \"coupled\": true,\n    \"with\": true,\n    \"service\": true,\n    \"implementation\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export const useFoo = () => {\\n  const [data, setData] = useState();\\n  const [loading, setLoading] = useState(true);\\n  const [error, setError] = useState();\\n  const fooService = new FooService();\\n  \\n  useEffect(() => {\\n    const isCanceled = false;\\n    asyncEffect();\\n    return () => {\\n      isCanceled = true;\\n    }\\n\\n    async function asyncEffect() {\\n      try {\\n        const data = await fooService.getData();\\n        if (isCanceled) {\\n          return;\\n        }\\n        setData(data);\\n        setLoading(false);\\n      } catch(error) {\\n        setError(error);\\n        setLoading(false);\\n      }\\n    }\\n  }, []);\\n\\n  return [data, loading, error];\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export const useFoo = () => {\\n  const [data, setData] = useState();\\n  const [loading, setLoading] = useState(true);\\n  const [error, setError] = useState();\\n  const fooService = new FooService();\\n  \\n  useEffect(() => {\\n    const isCanceled = false;\\n    asyncEffect();\\n    return () => {\\n      isCanceled = true;\\n    }\\n\\n    async function asyncEffect() {\\n      try {\\n        const data = await fooService.getData();\\n        const serverVersionResponse = await fetch(OTHER_SERVER_URL + '/version');\\n        const version = await serverVersionResponse.json();\\n        if (version !== data.version) {\\n          throw new Error('Version mismatch!');\\n        }\\n        if (isCanceled) {\\n          return;\\n        }\\n        setData(data);\\n        setLoading(false);\\n      } catch(error) {\\n        setError(error);\\n        setLoading(false);\\n      }\\n    }\\n  }, []);\\n\\n  return [data, loading, error];\\n}\\n\"))), mdx(\"hr\", null), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"Context\"), \" to the rescue!\"), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"class FooService {\\n  async getData(): Promise<Data> {\\n    const response = await fetch('/api/data');\\n    const json = await response.json();\\n    return json;\\n  }\\n}\\n\\nexport const useFoo = () => {\\n  const [data, setData] = useState();\\n  const [loading, setLoading] = useState(true);\\n  const [error, setError] = useState();\\n  const fooService = new FooService();\\n  \\n  useEffect(() => {\\n    const isCanceled = false;\\n    asyncEffect();\\n    return () => isCanceled = true;\\n    async function asyncEffect() {\\n      try {\\n        const data = fooService.getData();\\n        setData(data);\\n        setLoading(false);\\n      } catch(error) {\\n        setError(error);\\n        setLoading(false);\\n      }\\n    }\\n  }, []);\\n\\n  return [data, loading, error];\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"describe('<Result />', () => {\\n  it('renders a loading state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => new Promise(res => {})) // halt requests\\n    const { getByText } = render(<Result />);\\n    expect(getByText('Loading...')).toBeInTheDocument();\\n  });\\n\\n  it('renders an error state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => Promise.reject(new Error('Bad')));\\n    const { getByText } = render(<Result />);\\n    expect(getByText('Error: Bad')).toBeInTheDocument();\\n  });\\n\\n  it('renders the result state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => Promise.resolve({\\n      json: () => Promise.resolve([thing1, thing2]),\\n    }));\\n    const { getByText } = render(<Result />);\\n    expect(getByText(thing1.id)).toBeInTheDocument();\\n    expect(getByText(thing2.id)).toBeInTheDocument();\\n  });\\n});\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"class FooService {\\n  async getData(): Promise<Data> {\\n    const response = await fetch('/api/data');\\n    const json = await response.json();\\n    return json;\\n  }\\n}\\n\\nexport const FooServiceContext = createContext(new FooService());\\n\\nexport const useFoo = () => {\\n  const [data, setData] = useState();\\n  const [loading, setLoading] = useState(true);\\n  const [error, setError] = useState();\\n  const fooService = useContext(FooServiceContext);\\n  \\n  useEffect(() => {\\n    const isCanceled = false;\\n    asyncEffect();\\n    return () => isCanceled = true;\\n    async function asyncEffect() {\\n      try {\\n        const data = fooService.getData();\\n        setData(data);\\n        setLoading(false);\\n      } catch(error) {\\n        setError(error);\\n        setLoading(false);\\n      }\\n    }\\n  }, []);\\n\\n  return [data, loading, error];\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"describe('<Result />', () => {\\n  it('renders a loading state', () => {\\n    const fakeFooService = {\\n      getData: () => new Promise(res => {}),\\n    };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    expect(getByText('Loading...')).toBeInTheDocument();\\n  });\\n\\u200B\\n  it('renders an error state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => Promise.reject(new Error('Bad')));\\n    const { getByText } = render(<Result />);\\n    expect(getByText('Error: Bad')).toBeInTheDocument();\\n  });\\n\\u200B\\n  it('renders the result state', () => {\\n    const spy = jest.spyOn(global, 'fetch');\\n    spy.mockImplementation(() => Promise.resolve({\\n      json: () => Promise.resolve([thing1, thing2]),\\n    }));\\n    const { getByText } = render(<Result />);\\n    expect(getByText(thing1.id)).toBeInTheDocument();\\n    expect(getByText(thing2.id)).toBeInTheDocument();\\n  });\\n});\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"describe('<Result />', () => {\\n  it('renders a loading state', () => {\\n    const fakeFooService = {\\n      getData: () => new Promise(res => {}),\\n    };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    expect(getByText('Loading...')).toBeInTheDocument();\\n  });\\n\\n  it('renders an error state', () => {\\n    const fakeFooService = {\\n      getData: () => Promise.reject(new Error('Bad')),\\n    };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    expect(getByText('Error: Bad')).toBeInTheDocument();\\n  });\\n\\n  it('renders the result state', () => {\\n    const fakeFooService = {\\n      getData: () => Promise.resolve([thing1, thing2]),\\n    };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    expect(getByText(thing1.id)).toBeInTheDocument();\\n    expect(getByText(thing2.id)).toBeInTheDocument();\\n  });\\n});\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"4,17,30\",\n    \"4,17,30\": true\n  }), \"\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"describe('<Result />', () => {\\n  function setup(impl: () => Promise<Data>) {\\n    const fakeFooService = { getData: impl };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    return { getByText };\\n  }\\n\\n  it('renders a loading state', () => {\\n    const fakeFooService = {\\n      getData: () => new Promise(res => {}),\\n    };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    expect(getByText('Loading...')).toBeInTheDocument();\\n  });\\n\\n  it('renders an error state', () => {\\n    const fakeFooService = {\\n      getData: () => Promise.reject(new Error('Bad')),\\n    };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    expect(getByText('Error: Bad')).toBeInTheDocument();\\n  });\\n\\n  it('renders the result state', () => {\\n    const fakeFooService = {\\n      getData: () => Promise.resolve([thing1, thing2]),\\n    };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    expect(getByText(thing1.id)).toBeInTheDocument();\\n    expect(getByText(thing2.id)).toBeInTheDocument();\\n  });\\n});\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"describe('<Result />', () => {\\n  function setup(impl: () => Promise<Data>) {\\n    const fakeFooService = { getData: impl };\\n    const ResultWithFakeFooService = () => {\\n      <FooServiceContext.Provider value={fakeFooService}>\\n        <Result>\\n      </FooServiceContext.Provider>\\n    }\\n    const { getByText } = render(<ResultWithFakeFooService />);\\n    return { getByText };\\n  }\\n\\n  it('renders a loading state', () => {\\n    const { getByText } = setup(() => new Promise(res => {}));\\n    expect(getByText('Loading...')).toBeInTheDocument();\\n  });\\n\\n  it('renders an error state', () => {\\n    const { getByText } = setup(() => Promise.reject(new Error('Bad')));\\n    expect(getByText('Error: Bad')).toBeInTheDocument();\\n  });\\n\\n  it('renders the result state', () => {\\n    const { getByText } = setup(() => Promise.resolve([thing1, thing2]));\\n    expect(getByText(thing1.id)).toBeInTheDocument();\\n    expect(getByText(thing2.id)).toBeInTheDocument();\\n  });\\n});\\n\")))), mdx(\"hr\", null), mdx(\"h2\", null, \"Let's see a real world example\"), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export const useLogin = (): [User | undefined, React.FunctionComponent] => {\\n  const loginService = useContext(LoginServiceContext);\\n  const [user, setUser] = useState<User | undefined>();\\n  const [error, setError] = useState<Error | undefined>();\\n  const WrappedLogin: React.FunctionComponent = () => {\\n    return (\\n      <>\\n        {error && <div style={{ color: 'red' }}>{error.message}</div>}\\n        <LoginForm\\n          onLogin={async (username, password) => {\\n            try {\\n              setError(undefined);\\n              const user = await loginService.login(username, password);\\n              setUser(user);\\n            } catch  (error) {\\n              setError(error);\\n            }\\n          }}\\n        />\\n      </>\\n    );\\n  };\\n  return [user, WrappedLogin];\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// app.tsx\\nconst App: React.FunctionComponent = () => {\\n  const [user, Login] = useLogin();\\n  if (user) {\\n    return (\\n      <>\\n        <div>Welcome to AwesomeApp!</div>\\n        <AuthenticatedApp />\\n      </>\\n    );\\n  } else {\\n    return (\\n      <>\\n        <div>You need to login to use this App</div>\\n        <Login />\\n      </>\\n    );\\n  }\\n}\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// app.tsx\\nconst App: React.FunctionComponent = () => {\\n  const [user, Login] = useLogin();\\n  if (user) {\\n    return (\\n      <>\\n        <div>Welcome to AwesomeApp!</div>\\n        <AuthenticatedApp />\\n      </>\\n    );\\n  } else {\\n    return (\\n      <>\\n        <div>You need to login to use this App</div>\\n        <Login />\\n      </>\\n    );\\n  }\\n}\\n\\n// app.test.tsx\\ndescribe('<App />', () => {\\n  describe('when the user is unauthenticated', () => {\\n    // hmmm\\n  })\\n  describe('when the user is authenticated', () => {\\n    // hmmm\\n  });\\n});\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const useLogin = (): [User | undefined, React.FunctionComponent] => {\\n  const loginService = useContext(LoginServiceContext);\\n  const [user, setUser] = useState<User | undefined>();\\n  const [error, setError] = useState<Error | undefined>();\\n  const WrappedLogin: React.FunctionComponent = () => {\\n    return (\\n      <>\\n        {error && <div style={{ color: 'red' }}>{error.message}</div>}\\n        <LoginForm\\n          onLogin={async (username, password) => {\\n            try {\\n              setError(undefined);\\n              const user = await loginService.login(username, password);\\n              setUser(user);\\n            } catch  (error) {\\n              setError(error);\\n            }\\n          }}\\n        />\\n      </>\\n    );\\n  };\\n  return [user, WrappedLogin];\\n};\\n\\nexport const UseLoginContext = React.createContext(useLogin);\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// app.tsx\\nconst App: React.FunctionComponent = () => {\\n  const useLogin = useContext(UseLoginContext);\\n  const [user, Login] = useLogin();\\n  if (user) {\\n    return (\\n      <>\\n        <div>Welcome to AwesomeApp!</div>\\n        <AuthenticatedApp />\\n      </>\\n    );\\n  } else {\\n    return (\\n      <>\\n        <div>You need to login to use this App</div>\\n        <Login />\\n      </>\\n    );\\n  }\\n}\\n\\n// app.test.tsx\\ndescribe('<App />', () => {\\n  describe('when the user is unauthenticated', () => {\\n    // hmmm\\n  })\\n  describe('when the user is authenticated', () => {\\n    // hmmm\\n  });\\n});\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"// app.tsx\\nconst App: React.FunctionComponent = () => {\\n  const useLogin = useContext(UseLoginContext);\\n  const [user, Login] = useLogin();\\n  if (user) {\\n    return (\\n      <>\\n        <div>Welcome to AwesomeApp!</div>\\n        <AuthenticatedApp />\\n      </>\\n    );\\n  } else {\\n    return (\\n      <>\\n        <div>You need to login to use this App</div>\\n        <Login />\\n      </>\\n    );\\n  }\\n}\\n\\n// app.test.tsx\\ndescribe('<App />', () => {\\n  function setup(user: User | undefined) {\\n    const Host: React.FunctionComponent = () => {\\n      return (\\n        <UseLoginContext.Provider value={() => [user, () => null]}>\\n          <App />\\n        </UseLoginContext.Provider>\\n      );\\n    };\\n    const { getByText } = render(<Host />);\\n    return { getByText };\\n  }\\n\\n  describe('when the user is unauthenticated', () => {\\n    it('shows the dashboard', () => {\\n      const { getByText } = setup();\\n      expect(getByText('You need to login to use this App')).toBeInTheDocument();\\n    });\\n  })\\n\\n  describe('when the user is authenticated', () => {\\n    it('shows the dashboard', () => {\\n      const { getByText } = setup({ id: '123' });\\n      expect(getByText('Welcome to AwesomeApp!')).toBeInTheDocument();\\n    });\\n  });\\n});\\n\")))), mdx(\"hr\", null), mdx(\"h1\", null, \"FIN\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"524716f0-c4b8-59b9-be39-71b450728e45","slug":"/talks/di-providers","title":"Dependency Injection with <br /> Providers and Context"}}}